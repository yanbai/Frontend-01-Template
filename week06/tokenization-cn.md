实现必须表现得好像它们使用以下状态机来标记HTML。状态机必须以数据状态启动。大多数状态使用一个字符，
这可能会产生各种副作用，并将状态机切换到新状态以重新使用当前输入字符，或将其切换到新状态以使用下一个字符，
或保持相同状态以使用下一个字符。有些状态有更复杂的行为，在切换到另一个状态之前可以消耗几个字符。
在某些情况下，记号赋予器的状态也会在树构造阶段改变。

当一个状态表示重新使用指定状态下的匹配字符时，这意味着切换到该状态，但是当它试图使用下一个输入字符时，向它提供当前输入字符。

某些状态的确切行为取决于插入模式和开放元素的堆栈。某些状态还使用临时缓冲区来跟踪进度，而字符引用状态使用返回状态来返回它被调用时的状态。

标记化步骤的输出是一系列零个或多个以下标记:DOCTYPE、开始标记、结束标记、注释、字符、文件结束。
DOCTYPE令牌有一个名称、一个公共标识符、一个系统标识符和一个force-quirks标志。
创建DOCTYPE标记时，必须将其名称、公共标识符和系统标识符标记为missing(这是与空字符串不同的状态)，
并且必须将force-quirks标志设置为off(它的另一种状态为on)。
开始标记和结束标记有一个标记名、一个自关闭标志和一个属性列表，
每个属性都有一个名称和一个值。当创建开始或结束标记标记时，必须取消它的自关闭标志(它的另一种状态是被设置)，并且它的属性列表必须为空。
注释和字符标记都有数据。

当发出一个令牌时，它必须立即由树构造阶段进行处理。树形结构阶段可以影响标记化阶段的状态，并可以向流中插入其他字符。
(例如，脚本元素可以使脚本执行并使用动态标记插入api将字符插入到标记化的流中。)

创建令牌和发出令牌是截然不同的操作。有可能会创建一个标记，但隐式地放弃(从未发出)，
例如，如果文件在处理正在解析为开始标记标记的字符时意外结束。

当启动标记标记并设置其自关闭标志时，如果在树构造阶段处理该标志时没有确认该标志，
则会出现一个non- voidml -element-start-tag-with- trail- solidus解析错误。

当结束标记标记带有属性发出时，这是一个结束标记带有属性的解析错误。

当设置了自关闭标志并发出结束标记时，就会出现带跟踪的结束标记的solidus解析错误。

适当的结束标记标记是一个结束标记标记，它的标记名称与从这个记号赋予器发出的最后一个开始标记的标记名称相匹配(如果有的话)。如果这个记号赋予器没有发出开始标记，那么没有结束标记标记是合适的。

如果返回状态是属性值(双引号)状态、属性值(单引号)状态或属性值(无引号)状态，则称字符引用作为属性的一部分使用。

当一个国家说刷新代码点消耗字符引用,这意味着每个代码点的临时缓冲区(他们的顺序添加到缓冲)
用户代理必须附加代码点缓冲区的当前属性的值如果字符引用消费作为一个属性的一部分,或作为字符令牌发出代码点。

在标记器执行每一步之前，用户代理必须首先检查解析器的暂停标志。
如果为真，则记号赋予器必须中止对记号赋予器的任何嵌套调用的处理，将控制权交还给调用者。

记号赋予器状态机由以下子节中定义的状态组成。
